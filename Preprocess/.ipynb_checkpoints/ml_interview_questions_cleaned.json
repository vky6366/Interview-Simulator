[
    {
        "interview_questions": [
            {
                "id": 1,
                "question": "What's the trade-off between bias and variance?",
                "answer": "If our model is too simple and has very few parameters then it may have high bias and low variance. On the other hand if our model has large number of parameters then it's going to have high variance and low bias. So we need to find the right/good balance without overfitting and underfitting the data."
            },
            {
                "id": 2,
                "question": "What is gradient descent?",
                "answer": "Gradient descent is an optimization algorithm used to find the values of parameters (coefficients) of a function (f) that minimizes a cost function (cost). Gradient descent is best used when the parameters cannot be calculated analytically (e.g. using linear algebra) and must be searched for by an optimization algorithm."
            },
            {
                "id": 3,
                "question": "Explain over- and under-fitting and how to combat them?",
                "answer": "ML/DL models essentially learn a relationship between its given inputs(called training features) and objective outputs(called labels). Regardless of the quality of the learned relation(function), its performance on a test set(a collection of data different from the training input) is subject to investigation. Most ML/DL models have trainable parameters which will be learned to build that input-output relationship. Based on the number of parameters each model has, they can be sorted into more flexible(more parameters) to less flexible(less parameters). The problem of Underfitting arises when the flexibility of a model(its number of parameters) is not adequate to capture the underlying pattern in a training dataset. Overfitting, on the other hand, arises when the model is too flexible to the underlying pattern. In the later case it is said that the model has 'memorized' the training data. An example of underfitting is estimating a second order polynomial(quadratic function) with a first order polynomial(a simple line). Similarly, estimating a line with a 10th order polynomial would be an example of overfitting."
            },
            {
                "id": 4,
                "question": "How do you combat the curse of dimensionality?",
                "answer": [
                    "Feature Selection(manual or via statistical methods)",
                    "Principal Component Analysis (PCA)",
                    "Multidimensional Scaling",
                    "Locally linear embedding"
                ]
            },
            {
                "id": 5,
                "question": "What is regularization, why do we use it, and give some examples of common methods?",
                "answer": {
                    "definition": "A technique that discourages learning a more complex or flexible model, so as to avoid the risk of overfitting.",
                    "examples": [
                        "Ridge (L2 norm)",
                        "Lasso (L1 norm)"
                    ],
                    "additional_info": "The obvious disadvantage of ridge regression, is model interpretability. It will shrink the coefficients for least important predictors, very close to zero. But it will never make them exactly zero. In other words, the final model will include all predictors. However, in the case of the lasso, the L1 penalty has the effect of forcing some of the coefficient estimates to be exactly equal to zero when the tuning parameter λ is sufficiently large. Therefore, the lasso method also performs variable selection and is said to yield sparse models."
                }
            },
            {
                "id": 6,
                "question": "Explain Principal Component Analysis (PCA)?",
                "answer": "Principal Component Analysis (PCA) is a dimensionality reduction technique used in machine learning to reduce the number of features in a dataset while retaining as much information as possible. It works by identifying the directions (principal components) in which the data varies the most, and projecting the data onto a lower-dimensional subspace along these directions."
            },
            {
                "id": 7,
                "question": "Why is ReLU better and more often used than Sigmoid in Neural Networks?",
                "answer": {
                    "reasons": [
                        {
                            "title": "Computation Efficiency",
                            "description": "As ReLU is a simple threshold the forward and backward path will be faster."
                        },
                        {
                            "title": "Reduced Likelihood of Vanishing Gradient",
                            "description": "Gradient of ReLU is 1 for positive values and 0 for negative values while Sigmoid activation saturates (gradients close to 0) quickly with slightly higher or lower inputs leading to vanishing gradients."
                        },
                        {
                            "title": "Sparsity",
                            "description": "Sparsity happens when the input of ReLU is negative. This means fewer neurons are firing ( sparse activation ) and the network is lighter."
                        }
                    ]
                }
            },
            {
                "id": 8,
                "question": "Given stride S and kernel sizes for each layer of a (1-dimensional) CNN, create a function to compute the receptive field of a particular node in the network. This is just finding how many input nodes actually connect through to a neuron in a CNN.",
                "answer": "The receptive field are defined portion of space within an inputs that will be used during an operation to generate an output. Considering a CNN filter of size k, the receptive field of a peculiar layer is only the number of input used by the filter, in this case k, multiplied by the dimension of the input that is not being reduced by the convolutionnal filter a. This results in a receptive field of k*a. More visually, in the case of an image of size 32x32x3, with a CNN with a filter size of 5x5, the corresponding recpetive field will be the the filter size, 5 multiplied by the depth of the input volume (the RGB colors) which is the color dimensio. This thus gives us a recpetive field of dimension 5x5x3."
            },
            {
                "id": 9,
                "question": "Implement connected components on an image/matrix.",
                "answer": null
            },
            {
                "id": 10,
                "question": "Implement a sparse matrix class in C++.",
                "answer": null
            },
            {
                "id": 11,
                "question": "Create a function to compute an integral image, and create another function to get area sums from the integral image.",
                "answer": null
            },
            {
                "id": 12,
                "question": "How would you remove outliers when trying to estimate a flat plane from noisy samples?",
                "answer": "Random sample consensus (RANSAC) is an iterative method to estimate parameters of a mathematical model from a set of observed data that contains outliers, when outliers are to be accorded no influence on the values of the estimates."
            },
            {
                "id": 13,
                "question": "How does CBIR work?",
                "answer": "Content-based image retrieval is the concept of using images to gather metadata on their content. Compared to the current image retrieval approach based on the keywords associated to the images, this technique generates its metadata from computer vision techniques to extract the relevant informations that will be used during the querying step. Many approach are possible from feature detection to retrieve keywords to the usage of CNN to extract dense features that will be associated to a known distribution of keywords. With this last approach, we care less about what is shown on the image but more about the similarity between the metadata generated by a known image and a list of known label and or tags projected into this metadata space."
            },
            {
                "id": 14,
                "question": "How does image registration work? Sparse vs. dense optical flow and so on.",
                "answer": null
            },
            {
                "id": 15,
                "question": "Describe how convolution works. What about if your inputs are grayscale vs RGB imagery? What determines the shape of the next layer?",
                "answer": "In a convolutional neural network (CNN), the convolution operation is applied to the input image using a small matrix called a kernel or filter. The kernel slides over the image in small steps, called strides, and performs element-wise multiplications with the corresponding elements of the image and then sums up the results. The output of this operation is called a feature map. When the input is RGB(or more than 3 channels) the sliding window will be a sliding cube. The shape of the next layer is determined by Kernel size, number of kernels, stride, padding, and dialation."
            },
            {
                "id": 16,
                "question": "Talk me through how you would create a 3D model of an object from imagery and depth sensor measurements taken at all angles around the object.",
                "answer": {
                    "methods": [
                        {
                            "name": "Structure from Motion (SfM)",
                            "description": "Better suited for creating models of large scenes"
                        },
                        {
                            "name": "Multi-View Stereo (MVS)",
                            "description": "Better suited for creating models of small objects"
                        }
                    ]
                }
            },
            {
                "id": 17,
                "question": "Implement SQRT(const double & x) without using any special functions, just fundamental arithmetic.",
                "answer": "The taylor series can be used for this step by providing an approximation of sqrt(x)"
            },
            {
                "id": 18,
                "question": "Reverse a bitstring.",
                "answer": {
                    "python3_implementation": "data = b'\\xAD\\xDE\\xDE\\xC0'\nmy_data = bytearray(data)\nmy_data.reverse()"
                }
            },
            {
                "id": 19,
                "question": "Implement non maximal suppression as efficiently as you can.",
                "answer": {
                    "description": "Non-Maximum Suppression (NMS) is a technique used to eliminate multiple detections of the same object in a given image.",
                    "steps": [
                        "Sort bounding boxes based on their scores(N LogN)",
                        "Starting with the box with the highest score, remove boxes whose overlapping metric(IoU) is greater than a certain threshold.(N^2)"
                    ],
                    "optimization": "To optimize this solution you can use special data structures to query for overlapping boxes such as R-tree or KD-tree. (N LogN)"
                }
            },
            {
                "id": 20,
                "question": "Reverse a linked list in place.",
                "answer": null
            },
            {
                "id": 21,
                "question": "What is data normalization and why do we need it?",
                "answer": "Data normalization is very important preprocessing step, used to rescale values to fit in a specific range to assure better convergence during backpropagation. In general, it boils down to subtracting the mean of each data point and dividing by its standard deviation. If we don't do this then some of the features (those with high magnitude) will be weighted more in the cost function (if a higher-magnitude feature changes by 1%, then that change is pretty big, but for smaller features it's quite insignificant). The data normalization makes all features weighted equally."
            },
            {
                "id": 22,
                "question": "Why do we use convolutions for images rather than just FC layers?",
                "answer": {
                    "reasons": [
                        "Convolutions preserve, encode, and actually use the spatial information from the image. If we used only FC layers we would have no relative spatial information.",
                        "Convolutional Neural Networks (CNNs) have a partially built-in translation in-variance, since each convolution kernel acts as it's own filter/feature detector."
                    ]
                }
            },
            {
                "id": 23,
                "question": "What makes CNNs translation invariant?",
                "answer": "Each convolution kernel acts as it's own filter/feature detector. So let's say you're doing object detection, it doesn't matter where in the image the object is since we're going to apply the convolution in a sliding window fashion across the entire image anyways."
            },
            {
                "id": 24,
                "question": "Why do we have max-pooling in classification CNNs?",
                "answer": "For a role in Computer Vision. Max-pooling in a CNN allows you to reduce computation since your feature maps are smaller after the pooling. You don't lose too much semantic information since you're taking the maximum activation. There's also a theory that max-pooling contributes a bit to giving CNNs more translation in-variance."
            },
            {
                "id": 25,
                "question": "Why do segmentation CNNs typically have an encoder-decoder style / structure?",
                "answer": "The encoder CNN can basically be thought of as a feature extraction network, while the decoder uses that information to predict the image segments by 'decoding' the features and upscaling to the original image size."
            },
            {
                "id": 26,
                "question": "What is the significance of Residual Networks?",
                "answer": "The main thing that residual connections did was allow for direct feature access from previous layers. This makes information propagation throughout the network much easier. One very interesting paper about this shows how using local skip connections gives the network a type of ensemble multi-path structure, giving features multiple paths to propagate throughout the network."
            },
            {
                "id": 27,
                "question": "What is batch normalization and why does it work?",
                "answer": "Training Deep Neural Networks is complicated by the fact that the distribution of each layer's inputs changes during training, as the parameters of the previous layers change. The idea is then to normalize the inputs of each layer in such a way that they have a mean output activation of zero and standard deviation of one. This is done for each individual mini-batch at each layer i.e compute the mean and variance of that mini-batch alone, then normalize. This is analogous to how the inputs to networks are standardized. How does this help? We know that normalizing the inputs to a network helps it learn. But a network is just a series of layers, where the output of one layer becomes the input to the next. That means we can think of any layer in a neural network as the first layer of a smaller subsequent network. Thought of as a series of neural networks feeding into each other, we normalize the output of one layer before applying the activation function, and then feed it into the following layer (sub-network)."
            },
            {
                "id": 28,
                "question": "Why would you use many small convolutional kernels such as 3x3 rather than a few large ones?",
                "answer": {
                    "reasons": [
                        "You can use several smaller kernels rather than few large ones to get the same receptive field and capture more spatial context, but with the smaller kernels you are using less parameters and computations.",
                        "Because with smaller kernels you will be using more filters, you'll be able to use more activation functions and thus have a more discriminative mapping function being learned by your CNN."
                    ],
                    "source": "This is very well explained in the VGGNet paper."
                }
            },
            {
                "id": 29,
                "question": "Why do we need a validation set and test set? What is the difference between them?",
                "answer": {
                    "datasets": [
                        {
                            "name": "Training dataset",
                            "purpose": "Used for fitting the model's parameters. However, the accuracy that we achieve on the training set is not reliable for predicting if the model will be accurate on new samples."
                        },
                        {
                            "name": "Validation dataset",
                            "purpose": "Used to measure how well the model does on examples that weren't part of the training dataset. The metrics computed on the validation data can be used to tune the hyperparameters of the model. However, every time we evaluate the validation data and we make decisions based on those scores, we are leaking information from the validation data into our model."
                        },
                        {
                            "name": "Test dataset",
                            "purpose": "Used to measure how well the model does on previously unseen examples. It should only be used once we have tuned the parameters using the validation set."
                        }
                    ],
                    "conclusion": "So if we omit the test set and only use a validation set, the validation score won't be a good estimate of the generalization of the model."
                }
            },
            {
                "id": 30,
                "question": "What is stratified cross-validation and when should we use it?",
                "answer": {
                    "definition": "Cross-validation is a technique for dividing data between training and validation sets. On typical cross-validation this split is done randomly. But in stratified cross-validation, the split preserves the ratio of the categories on both the training and validation datasets.",
                    "example": "If we have a dataset with 10% of category A and 90% of category B, and we use stratified cross-validation, we will have the same proportions in training and validation. In contrast, if we use simple cross-validation, in the worst case we may find that there are no samples of category A in the validation set.",
                    "use_cases": [
                        "On a dataset with multiple categories. The smaller the dataset and the more imbalanced the categories, the more important it will be to use stratified cross-validation.",
                        "On a dataset with data of different distributions. For example, in a dataset for autonomous driving, we may have images taken during the day and at night."
                    ]
                }
            },
            {
                "id": 31,
                "question": "Why do ensembles typically have higher scores than individual models?",
                "answer": {
                    "main_concept": "An ensemble is the combination of multiple models to create a single prediction. The key idea for making better predictions is that the models should make different errors. That way the errors of one model will be compensated by the right guesses of the other models and thus the score of the ensemble will be higher.",
                    "diversity_methods": [
                        "Using different ML algorithms. For example, you can combine logistic regression, k-nearest neighbors, and decision trees.",
                        "Using different subsets of the data for training. This is called bagging.",
                        "Giving a different weight to each of the samples of the training set. If this is done iteratively, weighting the samples according to the errors of the ensemble, it's called boosting."
                    ],
                    "real_world_consideration": "Many winning solutions to data science competitions are ensembles. However, in real-life machine learning projects, engineers need to find a balance between execution time and accuracy."
                }
            },
            {
                "id": 32,
                "question": "What is an imbalanced dataset? Can you list some ways to deal with it?",
                "answer": {
                    "definition": "An imbalanced dataset is one that has different proportions of target categories. For example, a dataset with medical images where we have to detect some illness will typically have many more negative samples than positive samples—say, 98% of images are without the illness and 2% of images are with the illness.",
                    "solutions": [
                        {
                            "method": "Oversampling or undersampling",
                            "description": "Instead of sampling with a uniform distribution from the training dataset, we can use other distributions so the model sees a more balanced dataset."
                        },
                        {
                            "method": "Data augmentation",
                            "description": "We can add data in the less frequent categories by modifying existing data in a controlled way. In the example dataset, we could flip the images with illnesses, or add noise to copies of the images in such a way that the illness remains visible."
                        },
                        {
                            "method": "Using appropriate metrics",
                            "description": "In the example dataset, if we had a model that always made negative predictions, it would achieve a precision of 98%. There are other metrics such as precision, recall, and F-score that describe the accuracy of the model better when using an imbalanced dataset."
                        }
                    ]
                }
            },
            {
                "id": 33,
                "question": "Can you explain the differences between supervised, unsupervised, and reinforcement learning?",
                "answer": {
                    "learning_types": [
                        {
                            "type": "Supervised Learning",
                            "description": "We train a model to learn the relationship between input data and output data. We need to have labeled data to be able to do supervised learning."
                        },
                        {
                            "type": "Unsupervised Learning",
                            "description": "We only have unlabeled data. The model learns a representation of the data. Unsupervised learning is frequently used to initialize the parameters of the model when we have a lot of unlabeled data and a small fraction of labeled data."
                        },
                        {
                            "type": "Reinforcement Learning",
                            "description": "The model has some input data and a reward depending on the output of the model. The model learns a policy that maximizes the reward. Reinforcement learning has been applied successfully to strategic games such as Go and even classic Atari video games."
                        }
                    ]
                }
            },
            {
                "id": 34,
                "question": "What is data augmentation? Can you give some examples?",
                "answer": {
                    "definition": "Data augmentation is a technique for synthesizing new data by modifying existing data in such a way that the target is not changed, or it is changed in a known way.",
                    "computer_vision_examples": [
                        "Resize",
                        "Horizontal or vertical flip",
                        "Rotate",
                        "Add noise",
                        "Deform",
                        "Modify colors"
                    ],
                    "note": "Each problem needs a customized data augmentation pipeline. For example, on OCR, doing flips will change the text and won't be beneficial; however, resizes and small rotations may help."
                }
            },
            {
                "id": 35,
                "question": "What is Turing test?",
                "answer": "The Turing test is a method to test the machine's ability to match the human level intelligence. A machine is used to challenge the human intelligence that when it passes the test, it is considered as intelligent. Yet a machine could be viewed as intelligent without sufficiently knowing about people to mimic a human."
            },
            {
                "id": 36,
                "question": "What is Precision?",
                "answer": {
                    "definition": "Precision (also called positive predictive value) is the fraction of relevant instances among the retrieved instances",
                    "formula": "Precision = true positive / (true positive + false positive)"
                }
            },
            {
                "id": 37,
                "question": "What is Recall?",
                "answer": {
                    "definition": "Recall (also known as sensitivity) is the fraction of relevant instances that have been retrieved over the total amount of relevant instances.",
                    "formula": "Recall = true positive / (true positive + false negative)"
                }
            },
            {
                "id": 38,
                "question": "Define F1-score.",
                "answer": {
                    "definition": "It is the weighted average of precision and recall. It considers both false positive and false negative into account. It is used to measure the model's performance.",
                    "formula": "F1-Score = 2 * (precision * recall) / (precision + recall)"
                }
            },
            {
                "id": 39,
                "question": "What is cost function?",
                "answer": "Cost function is a scalar functions which Quantifies the error factor of the Neural Network. Lower the cost function better the Neural network. Eg: MNIST Data set to classify the image, input image is digit 2 and the Neural network wrongly predicts it to be 3"
            },
            {
                "id": 40,
                "question": "List different activation neurons or functions.",
                "answer": [
                    "Linear Neuron",
                    "Binary Threshold Neuron",
                    "Stochastic Binary Neuron",
                    "Sigmoid Neuron",
                    "Tanh function",
                    "Rectified Linear Unit (ReLU)"
                ]
            },
            {
                "id": 41,
                "question": "Define Learning Rate.",
                "answer": "Learning rate is a hyper-parameter that controls how much we are adjusting the weights of our network with respect the loss gradient."
            },
            {
                "id": 42,
                "question": "What is Momentum (w.r.t NN optimization)?",
                "answer": "Momentum lets the optimization algorithm remembers its last step, and adds some proportion of it to the current step. This way, even if the algorithm is stuck in a flat region, or a small local minimum, it can get out and continue towards the true minimum."
            },
            {
                "id": 43,
                "question": "What is the difference between Batch Gradient Descent and Stochastic Gradient Descent?",
                "answer": {
                    "batch_gradient_descent": "Batch gradient descent computes the gradient using the whole dataset. This is great for convex, or relatively smooth error manifolds. In this case, we move somewhat directly towards an optimum solution, either local or global. Additionally, batch gradient descent, given an annealed learning rate, will eventually find the minimum located in it's basin of attraction.",
                    "stochastic_gradient_descent": "Stochastic gradient descent (SGD) computes the gradient using a single sample. SGD works well for error manifolds that have lots of local maxima/minima. In this case, the somewhat noisier gradient calculated using the reduced number of samples tends to jerk the model out of local minima into a region that hopefully is more optimal."
                }
            },
            {
                "id": 44,
                "question": "Epoch vs. Batch vs. Iteration.",
                "answer": {
                    "epoch": "one forward pass and one backward pass of all the training examples",
                    "batch": "examples processed together in one pass (forward and backward)",
                    "iteration": "number of training examples / Batch size"
                }
            },
            {
                "id": 45,
                "question": "What is vanishing gradient?",
                "answer": "As we add more and more hidden layers, back propagation becomes less and less useful in passing information to the lower layers. In effect, as information is passed back, the gradients begin to vanish and become small relative to the weights of the networks."
            },
            {
                "id": 46,
                "question": "What are dropouts?",
                "answer": "Dropout is a simple way to prevent a neural network from overfitting. It is the dropping out of some of the units in a neural network. It is similar to the natural reproduction process, where the nature produces offsprings by combining distinct genes (dropping out others) rather than strengthening the co-adapting of them."
            },
            {
                "id": 47,
                "question": "Define LSTM.",
                "answer": "Long Short Term Memory – are explicitly designed to address the long term dependency problem, by maintaining a state what to remember and what to forget."
            },
            {
                "id": 48,
                "question": "List the key components of LSTM.",
                "answer": [
                    "Gates (forget, Memory, update & Read)",
                    "tanh(x) (values between -1 to 1)",
                    "Sigmoid(x) (values between 0 to 1)"
                ]
            },
            {
                "id": 49,
                "question": "List the variants of RNN.",
                "answer": [
                    "LSTM: Long Short Term Memory",
                    "GRU: Gated Recurrent Unit",
                    "End to End Network",
                    "Memory Network"
                ]
            },
            {
                "id": 50,
                "question": "What is Autoencoder, name few applications.",
                "answer": {
                    "definition": "Auto encoder is basically used to learn a compressed form of given data.",
                    "applications": [
                        "Data denoising",
                        "Dimensionality reduction",
                        "Image reconstruction",
                        "Image colorization"
                    ]
                }
            },
            {
                "id": 51,
                "question": "What are the components of GAN?",
                "answer": [
                    "Generator",
                    "Discriminator"
                ]
            },
            {
                "id": 52,
                "question": "What's the difference between boosting and bagging?",
                "answer": {
                    "common_ground": "Boosting and bagging are similar, in that they are both ensembling techniques, where a number of weak learners (classifiers/regressors that are barely better than guessing) combine (through averaging or max vote) to create a strong learner that can make accurate predictions.",
                    "differences": {
                        "bagging": "Bagging means that you take bootstrap samples (with replacement) of your data set and each sample trains a (potentially) weak learner.",
                        "boosting": "Boosting, on the other hand, uses all data to train each learner, but instances that were misclassified by the previous learners are given more weight so that subsequent learners give more focus to them during training."
                    }
                }
            },
            {
                "id": 53,
                "question": "Explain how a ROC curve works.",
                "answer": "The ROC curve is a graphical representation of the contrast between true positive rates and the false positive rate at various thresholds. It's often used as a proxy for the trade-off between the sensitivity of the model (true positives) vs the fall-out or the probability it will trigger a false alarm (false positives)."
            },
            {
                "id": 54,
                "question": "What's the difference between Type I and Type II error?",
                "answer": {
                    "type_i": "Type I error is a false positive - claiming something has happened when it hasn't",
                    "type_ii": "Type II error is a false negative - claiming nothing is happening when in fact something is",
                    "example": "A clever way to think about this is to think of Type I error as telling a man he is pregnant, while Type II error means you tell a pregnant woman she isn't carrying a baby."
                }
            },
            {
                "id": 55,
                "question": "What's the difference between a generative and discriminative model?",
                "answer": {
                    "generative": "A generative model will learn categories of data",
                    "discriminative": "A discriminative model will simply learn the distinction between different categories of data",
                    "performance_note": "Discriminative models will generally outperform generative models on classification tasks."
                }
            },
            {
                "id": 56,
                "question": "Instance-Based Versus Model-Based Learning.",
                "answer": {
                    "instance_based": "The system learns the examples by heart, then generalizes to new cases using a similarity measure.",
                    "model_based": "Another way to generalize from a set of examples is to build a model of these examples, then use that model to make predictions. This is called model-based learning."
                }
            },
            {
                "id": 57,
                "question": "When to use a Label Encoding vs. One Hot Encoding?",
                "answer": {
                    "one_hot_encoding": {
                        "when_to_use": [
                            "The categorical feature is not ordinal (like the countries above)",
                            "The number of categorical features is less so one-hot encoding can be effectively applied"
                        ]
                    },
                    "label_encoding": {
                        "when_to_use": [
                            "The categorical feature is ordinal (like Jr. kg, Sr. kg, Primary school, high school)",
                            "The number of categories is quite large as one-hot encoding can lead to high memory consumption"
                        ]
                    }
                }
            },
            {
                "id": 58,
                "question": "What is the difference between LDA and PCA for dimensionality reduction?",
                "answer": {
                    "main_difference": "Both LDA and PCA are linear transformation techniques: LDA is a supervised whereas PCA is unsupervised – PCA ignores class labels.",
                    "approach": {
                        "pca": "PCA as a technique that finds the directions of maximal variance",
                        "lda": "LDA attempts to find a feature subspace that maximizes class separability"
                    }
                }
            },
            {
                "id": 59,
                "question": "What is t-SNE?",
                "answer": "t-Distributed Stochastic Neighbor Embedding (t-SNE) is an unsupervised, non-linear technique primarily used for data exploration and visualizing high-dimensional data. In simpler terms, t-SNE gives you a feel or intuition of how the data is arranged in a high-dimensional space."
            },
            {
                "id": 60,
                "question": "What is the difference between t-SNE and PCA for dimensionality reduction?",
                "answer": {
                    "historical_context": "PCA was developed in 1933 while t-SNE was developed in 2008. A lot has changed in the world of data science since 1933 mainly in the realm of compute and size of data.",
                    "technical_differences": {
                        "pca": "PCA is a linear dimension reduction technique that seeks to maximize variance and preserves large pairwise distances. In other words, things that are different end up far apart.",
                        "tsne": "t-SNE differs from PCA by preserving only small pairwise distances or local similarities whereas PCA is concerned with preserving large pairwise distances to maximize variance."
                    }
                }
            },
            {
                "id": 61,
                "question": "What is UMAP?",
                "answer": "UMAP (Uniform Manifold Approximation and Projection) is a novel manifold learning technique for dimension reduction. UMAP is constructed from a theoretical framework based in Riemannian geometry and algebraic topology. The result is a practical scalable algorithm that applies to real world data."
            },
            {
                "id": 62,
                "question": "What is the difference between t-SNE and UMAP for dimensionality reduction?",
                "answer": {
                    "main_difference": "The biggest difference between the output of UMAP when compared with t-SNE is this balance between local and global structure - UMAP is often better at preserving global structure in the final projection.",
                    "interpretation_note": "However, it's important to note that, because UMAP and t-SNE both necessarily warp the high-dimensional shape of the data when projecting to lower dimensions, any given axis or distance in lower dimensions still isn't directly interpretable in the way of techniques such as PCA."
                }
            },
            {
                "id": 63,
                "question": "How Random Number Generator Works, e.g. rand() function in python works?",
                "answer": "It generates a pseudo random number based on the seed and there are some famous algorithm, please see below link for further information on this."
            },
            {
                "id": 64,
                "question": "Given that we want to evaluate the performance of 'n' different machine learning models on the same data, why would the following splitting mechanism be incorrect?",
                "answer": {
                    "problem": "The rand() function orders the data differently each time it is run, so if we run the splitting mechanism again, the 80% of the rows we get will be different from the ones we got the first time it was run.",
                    "issue": "This presents an issue as we need to compare the performance of our models on the same test set.",
                    "solutions": [
                        "Set the random seed in advance",
                        "Store the data once it is split",
                        "Set the 'random_state' parameter in sklearn's train_test_split() function"
                    ],
                    "code_example": {
                        "language": "python",
                        "code": "def get_splits():\n    df = pd.DataFrame(...)\n    rnd = np.random.rand(len(df))\n    train = df[ rnd < 0.8 ]\n    valid = df[ rnd >= 0.8 & rnd < 0.9 ]\n    test = df[ rnd >= 0.9 ]\n\n    return train, valid, test"
                    }
                }
            },
            {
                "id": 65,
                "question": "What is the difference between Bayesian vs frequentist statistics?",
                "answer": {
                    "frequentist": "Frequentist statistics is a framework that focuses on estimating population parameters using sample statistics, and providing point estimates and confidence intervals.",
                    "bayesian": "Bayesian statistics, on the other hand, is a framework that uses prior knowledge and information to update beliefs about a parameter or hypothesis, and provides probability distributions for parameters.",
                    "main_difference": "The main difference is that Bayesian statistics incorporates prior knowledge and beliefs into the analysis, while frequentist statistics doesn't."
                }
            },
            {
                "id": 66,
                "question": "What is the basic difference between LSTM and Transformers?",
                "answer": "LSTMs (Long Short Term Memory) models consist of RNN cells designed to store and manipulate information across time steps more efficiently. In contrast, Transformer models contain a stack of encoder and decoder layers, each consisting of self attention and feed-forward neural network components."
            },
            {
                "id": 67,
                "question": "What are RCNNs?",
                "answer": "Recurrent Convolutional model is a model that is specially designed to make predictions using a sequence of images (more commonly also know as video). These models are used in object detection tasks in computer vision. The RCNN approach combines both region proposal techniques and convolutional neural networks (CNNs) to identify and locate objects within an image."
            }
        ]
    }
]